#### 函数调用——在主函数中调用其他函数
> - ``print(void)``中的void表示“没有函数参数(无参函数，与之对应的是有参函数)”,如果调用该函数时给了实参，编译时就会报错；void也可以省略
> - main函数是由系统调用(是项目的入口函数，自定义的，不是库函数，不需要头文件)的，其他函数不能调用main函数
> - 函数不能嵌套定义

#### 定义函数的一般形式
> - c语言中规定：如果在定义函数时不指定函数类型，系统默认为int型，但c++要求定义函数时必须指定函数类型，更加安全

#### 函数参数和值
> - 形参(formal parameter)和实参(actual parameter)
>     - 在定义函数时指定的形参，在未出现函数调用时，并不占内存，因此称为**形式参数或虚拟参数**，表示它们并不是实际存在的数据，只要发生函数调用时，形参才分配内存单元，以便接收从实参传来的数据。调用结束后，形参所占内存单元被释放
>     - 实参可以是常量、变量或表达式，如``max(3, a + b)``，但要求a和b有确定的值
>     - 实参与形参的类型应相同或**赋值兼容**：如字符型与整形可以互相通用(ASCII码)
> - 函数的返回值
>     - ``return z;``与``return(z);``等价
>     - 如果函数值的类型与return语句表达式的值不一致，则以函数的类型为准，即函数类型决定返回值类型。对数值型数据，可以自动进行类型转换

#### 函数的调用
> - 如果实参列表包含多个实参，对实参求值的顺序并不是确定的。如i的值为3，``fun(i, ++i);``,从左往右为``fun(3, 4)``；从右往左为``fun(3, 3)``。大部分c++系统(如g++等)是按**从右向左**顺序求值的。
> - 函数作为一个函数的参数被调用：``m = max(a, max(b, c);``
> - **函数的定义和声明并不是同一件事情**。定义是指对函数功能的确立，包括指定函数名、函数类型、形参及其类型、函数体等，是一个独立完整的单位；而声明的作用是把函数的名字、函数类型以及形参的个数、类型和顺序(不包括函数体)通知编译系统，以便在对包含函数调用的语句进行编译时，据此对其进行对照检查(检查函数名是否正确、实参与形参的类型和个数是否一致)
>     - 在函数声明中也可以不写形参名，只写形参类型，如``float add(float, float);``这种声明称为**函数原型(function prototype)**,其作用是：根据函数原型在程序编译阶段对调用函数的合法性进行全面检查。**编译器并不检查参数名**
>     - 函数原型能够把函数的作用域扩展到定义该函数的文件之外(不必用extern)。只要在使用该函数的每一个文件中包含该函数的函数原型即可。函数原型通知编译系统：该函数在本文件中稍后定义，或在另一文件中定义。
>     - 利用函数原型扩展函数作用域最常见的是#include命令的应用
> - 一个好的习惯是把声明写在前面，然后是main函数，最后是函数定义，这样便于阅读

#### 内置函数
> 调用函数时需要一定的时间和空间的开销。程序调用的过程：1. 先执行函数调用之前的语句；2. 流程的控制转移到被调用函数的入口处，同时进行参数传递；3. 执行被调用函数中函数体的语句；4. 流程返回调用函数的下一条指令处，将返回值带回；5. 接着执行主调函数中未执行的语句。
> 这就要求转到被调函数之前，要记下当时执行的指令的地址，还要“保护现场”(记下有关信息)；在函数调用后，流程返回都先前记下的地址处，并且根据记下的信息“恢复现场”。这都需要花费时间
> c++提供一种高效的方法，即在编译时将所调用函数的代码直接嵌入到主调函数中，而不是将流程转出去。这种函数称为**内置函数(inline function, 又叫内联函数)**。使用关键字inline即可：``inline int max(int, int, int);``
> 可以在函数的声明和定义处同时写inline，也可以只在其中一处声明inline，效果相同
> 函数规模很小的情况下，函数调用的时间开销可能相当于甚至超过执行函数本身的时间，把它定义为内联函数可以减少运行时间
> **内联函数中不能包括复杂的控制语句，如循环语句和switch语句**
> 对函数作inline声明，只是程序设计者对编译系统提出的一个建议，而不是指令性的。编译系统会根据具体情况决定是否要这样做，如上一点中的循环语句和switch语句，或一个递归函数是无法进行代码置换的

#### 函数的重载
> c++允许用**同一个函数名**定义多个函数，这些函数的**参数个数和参数类型不同**。这就是函数的重载(function overloading)；除此之外，运算符也可以重载，如<<和>>既可以作为位移运算符，又可以作为输出流中的插入运算符和输入流中的提取运算符
> 系统会根据调用函数时给出的信息去找与之匹配的函数

#### 函数模板(function template)
> 所谓函数模板，就是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。凡是函数体相同的函数都可以用这个模板来代替，**不必定义多个函数**，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。
```cpp
#include <iostream>
using namespace std;
template<typename T>      //模板声明，其中T为类型参数，也可以写作template <class T>
T max(T a, T b, T c)      //定义了一个通用函数，用T作虚拟的类型名
{
    if (b > a)
        a = b;
    if (c > a)
        a = c;
    return a;
}

int main()
{
    int i1 = 2929, i2 = -9304, i3 = 0.577215, i;
    double d1 = 394.092, d2 = 8743.22, d3 = -890.59, d;
    long g1 = 92830, g2 = -3205943, g3 = 84950349, g;
    i = max(i1, i2, i3);             //调用模板函数，此时T被int取代
    d = max(d1, d2, d3);
    g = max(g1, g2, g3);
    cout<<"i_max = "<<i<<endl;
    cout<<"d_max = "<<d<<endl;
    cout<<"g_max = "<<g<<endl;
    return 0;
}
```
> 只适用于函数的参数个数相同而类型不同，且函数体相同 情况。

#### 有默认参数的函数
> 多次调用统一函数使用同样的实参，可以给形参一个默认值，这样形参就不必一定要从实参取值了
> 实参与形参的结合是从左至右顺序进行的，因此指定的默认值的参数必须放在形参列表中的**最右端**，否则出错
```cpp
void f1(float a, int b = 0, int c, char d = 'a');   //不正确
void f2(float a, int c, int b = 0, char d = 'a');   //正确

//调用f2
f2(3.5, 5, 3, 'x');    //形参的值全部从实参得到
f2(3.5, 5, 3);      //最后一个形参的值取默认值'a'
```
> 在调用有默认参数的函数时，实参的个数可以与形参的个数不同，实参未给定的，从形参的默认值得到值
> 注意：
>   - 如果函数的定义在函数调用之前，则应该在函数定义中给出默认值；如果定义在调用之后，则在函数调用之前需要由函数声明，此时必须在函数声明中给出默认值，在函数定义时可以不给出默认值
>   - 一个函数不能既作为重载函数，又作为有默认参数的函数，因为当调用函数少写一个参数，系统无法判定是利用重载哈数还是利用默认参数的函数，出现二义性。

#### 函数的递归调用
> 在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归(recurse)调用

#### 局部变量和全局变量
> 建议不在必要时不要使用全局变量
>   - 全局变量在程序的全部执行过程中都要占用存储单元
>   - 使函数的通用性降低，因为在执行函数时受到外部变量的影响(在程序设计中，在划分模块时要求模块的内聚性强、与其他模块的耦合性弱。即模块的功能要单一，与其他模块的相互影响尽量少，而全局变量是不符合这个原则的)。一般要求函数只能通过实参——形参与外界发生联系
>   - 使用全局变量过多，会降低程序的清晰性
> 变量的有效范围称为变量的作用域(scope)。共有四种：文件作用域(file scope)、函数作用域(function scope)、块作用域(block scope)和函数原型作用域(function prototype scope)。文件作用域是全局的，其他都是局部的

#### 变量的存储类别
> - 动态存储方式与静态存储方式
>   - 存储期(storage duration，也称生命期)。指比变量在内存中的存在期间。分为静态存储期(static storage duration)和动态存储期(dynamic storage duration)。这是由变量的静态存储方式和动态存储方式决定的
>   - 静态存储方式：程序运行期间，系统对变量分配固定的存储空间，执行完后释放。静态存储区：存放全局变量
>   - 动态存储区存放：1. 函数形式参数。在调用函数时给形参分配存储空间。 2. 函数中的自动变量(未加static声明的局部变量)。 3. 函数调用时的现场保护和返回地址等
>   - c++中变量除了有**数据类型**的属性外，还有**存储类型(storage class)**的属性。存储类别指的是数据在内存中存储的方法。存储方法分为静态存储和动态存储两大类。具体包含4种：自动的(auto)、静态的(static)，寄存器的(register)和外部的(extern)。根据变量的存储类别，可以知道变量的作用域和存储期
> - 自动变量(auto variable)
>   - 用关键字auto作存储类别的声明
>   - 存储类别和数据类型的顺序任意。关键字auto可以省略，如果不写auto则默认为自动存储类别
> - 用static声明静态局部变量(static local variable)
>   - 为静态局部变量赋初值是在编译时进行的，即只赋值一次。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值；而为自动变量赋初值不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值。
>   - 如果定义局部变量时不赋初值的话，对于静态局部变量来说，编译时自动赋初值0或空字符。而对自动变量来说，如果不赋初值，则它的值是不确定的。
>   - 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用的，也就是说它对其他函数是“不可见的”
>   - 如不必要，不要多用静态局部变量
> - 用register声明寄存器变量
>   - 在程序中定义寄存器变量对编译系统只是建议性的。并且编译器通常会自动优化。
> - 用extern声明外部变量
>   - 在一个文件内声明全局变量：如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件终了。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量作外部变量声明，表明该变量是一个将在下面定义的全局变量。有了此声明，就可以从声明处起，合法地引用该全局变量，这种声明称为**提前引用声明**
>   - 在多文件的程序中声明外部变量：在任一个文件中定义外部变量，而在另一文件中用extern对该变量作**外部变量声明**。编译系统由此知道该变量是一个已在别处定义的外部变量，它现在本文件中找有无外部变量，如果有，则将其作用域扩展到本行开始。如果没有，则在程序连接时从其他文件中找有无外部变量，如果有，则把在另一文件中定义的外部变量的作用域扩展到本文件。
> - 用static声明静态外部变量
>   - 在定义外部变量时加一个static声明，则该变量只限于被本文件引用，而不能被其他文件引用。

#### 关于变量的声明和定义
> - 变量的声明
>   - 定义性声明(defining declaration, 简称定义):``int a;``
>   - 引用性声明(referenceing declaration):``extern int a;``
> - 广义地说，声明包括定义，但并非所有的声明都是定义。为了叙述方便，把建立存储空间的声明称为定义，把不需要建立存储空间的声明称为声明

#### 内部函数和外部函数
> - 内部函数：函数只能被本文件中其他函数所调用，如``static int fun(int a, int b)``
> - 外部函数：定义函数时，加上extern关键字，表示可以被其他文件调用，``extern int fun(int a, int b)``

#### 预处理命令(preprocessor directives)
> 预处理命令时C++统一规定的，但是它不是C++语言本身的组成部分，不能直接对它们进行编译(因为编译程序不能识别它们)。必须在对程序进行通常的编译(包括词法和语法分析、代码生成、优化等)之前，先对程序中这些特殊的命令进行“预处理”，即根据预处理命令对程序作相应的处理。经过预处理后程序不再包括预处理命令了，最后再由编译程序对预处理后的源程序进行通常的编译处理，得到可供执行的目标代码。
> C++提供的预处理功能主要有3种：宏定义、文件包含、条件编译
> - 宏定义
>   - 宏定义的作用一般是用一个短的名字代表一个长的字符串。在C语言中用#defne定义符号常量，由于C++已增加了const定义常变量，因此#define实际上不多用
>   - 用#define定义带参数的宏定义。``#define 宏名(参数表) 字符串``，如``#define S(a, b) a * b      //定义宏S(矩形面积)``，使用：``area = S(3, 2)``。由于C++增加了内置函数(inline)，比用带参数的宏定义更方便，因此基本不再用#define命令定义宏了
> - “文件包含”处理
>   - 文件包含是指一个源文件可以将另外一个源文件的全部内容包含进来，即将另外的文件包含到本文件中
>   - 头文件一般包含以下内容：
>       - 对类型的声明。包括自定义类型和类类型
>       - 函数声明。函数的定义不是放在头文件中的，是放在函数库中或单独编译成目标文件的，在编译链接阶段与用户文件连接组成可执行文件
>       - 内置(inline)函数的定义。
>       - 宏定义。用#define定义的符号常量和用const声明的常变量
>       - 全局变量定义
>       - 外部变量声明。如``extern int a;``
>       - 还可以包含其他头文件
>   - C++标准库：一般不包含后缀.h
> - 条件编译
>   - 一般情况下在进行编译时对源程序中的每一行都要编译。但是有时希望程序中某一部分内容只在满足一定条件时才进行编译，也就是指定对程序中的一部分内容进行编译的条件。如果不满足就不编译这部分内容，称为“条件编译”
>   - 形式
```c
#ifdef 标识符
    程序段 1
#else
    程序段 2
#endif
//作用是当所指定的标识符已经被#define命令定义过，则在编译阶段只编译程序段1，否则编译程序段2.#endif用来限定#ifdef命令的范围。其中#else部分也可以没有

#if 表达式
    程序段 1
#else
    程序段 2
#endif
//其作用是当指定的表达式值为真(非零)时就编译程序段1，否则编译程序段2

//在调试程序时，常希望输出一些所需的信息，而在调试完成后不再输出。可以插入条件编译段
#include <iostream>
using namespace std;
#define RUN        //在调试程序时使之成为注释行,被定义的标识符不一定用run，只是为了见名知意
int main()
{
    int x = 1, y = 2, z = 3;
    #ifdef RUN     //本行为条件编译命令 
        cout<<"x = "<<x<<", y="<<", z="<<z;
    #endif
    cout<<"x*y*z="<<x*y*z<<endl;
    return 0;
}
```
