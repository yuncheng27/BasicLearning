#### 几个概念
> - 对象：客观世界中任何一个事物都可以看成一个对象(object)。任何一个对象都应当具有两个要素，即属性(attribute)和行为(behavior)，它能根据外界给出的信息进行相应的操作。在C++中，每个对象都是由数据和函数(即操作代码)两部分组成，数据体现了“属性”，函数则用来对数据进行操作，实现某些功能(行为)。调用对象中的函数就是向该对象传送一个消息(message)，要求该对象实现某一行为(功能)
> - 封装与信息隐蔽：可以对一个对象进行封装处理，把它的一部分属性和功能对外界屏蔽。即**把对象的内部实现和外部行为分隔开来**。面向对象程序设计方法的一个重要特点就是封装性(encapsulation)，所谓“封装”，指两方面的含义：一是将有关的数据和操作代码封装在一个对象中，形成一个基本单位，各个对象之间相互独立，互不干扰。二是将对象中某些部分对外隐藏，只留下少量接口，以便于外界联系，接收消息。这种对外界隐蔽的做法称为信息隐蔽(information hiding)。信息隐蔽有利于数据安全。C++对象中的函数名就是对象的对外接口
> - 抽象(abstraction)：抽象的作用是表示同一类事物的本质。C++中，类是对象的抽象，而对象则是类的特例，或者说是类的具体表现形式。
> - 继承与重用：在原有类的基础上增加一些属性和行为，就是继承机制，利用继承可以简化程序设计步骤；利用继承机制可以很方便地重用已有软件中的一部分甚至大部分，大大节省了编程工作量，这就是软件重用(software reusability)的思想。
> - 多态性(polymorphism)：由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应，能增加程序的灵活性。
> - 面向对象程序设计的特点：设计者需要考虑两方面，一是设计所需的各种类和对象，即决定把哪些数据和操作封装在一起；二是考虑怎样向有关对象发送消息，以完成所需任务。这时他如同一个总调度，不断地向各个对象发出命令，让这些对象活动起来(或者说激活这些对象)，完成自己职责范围内的工作。各个对象的操作完了，整体任务也就完成了。
> - 类和对象的作用：C++被称为“带类的C”。类是所有面向对象的共同特征。**基于对象**就是基于类。与面向过程的程序不同，基于对象的程序是以类加对象为基础的，程序的操作是围绕对象进行的。在此基础上**利用了继承机制和多态性**，就称为面向对象的程序设计(有时并不区分这两者的概念)。**基于对象程序设计**所面对的是一个个对象。所有的数据分别属于不同的对象。面向过程的程序中数据是共用(共享)的，即数据是缺乏保护的。数据的交叉使用很容易导致程序的错误。因此人们把相关数据和操作放在一起，形成一个整体，与外界相对分隔。这就是面向对象的程序设计中的对象。
> - 在面向过程中：程序=算法+数据结构；而基于对象和面向对象程序设计：**对象=算法+数据结构**   **程序=(对象+对象+对象+...) + 消息  或：程序= 对象s + 消息**   对象s表示多个对象。消息的作用就是对对象的控制
> - 面向对象的软件开发
>   - 面向对象分析(object oriented analysis, OOA)：按照面向对象的概念和方法，在对任务的分析中，从客观存在的事物和事物之间的关系，归纳出有关的对象(包括对象的属性和行为)以及对象之间的联系，并将具有相同属性和行为的对象用一个类(class)来表示
>   - 面向对象设计(object oriented design, OOD)：根据面向对象分析阶段形成的需求模型，对每一部分分别进行具体的设计，首先是进行类的设计，类的设计可能包含多个层次(利用继承与派生)。然后在此基础上进行算法的设计，利用**伪代码或流程图**
>   - 面向对象编程(object oriented programming, OOP)：根据面向对象设计的结果，用一种语言(如C++)把它写成程序。
>   - 面向对象测试(object oriented test, OOT)：使用之前，必须对程序进行严格的测试。测试的目的是发现程序中的错误并改正它。
>   - 面向对象维护(object oriented soft maintenance, OOSM)

#### 类的声明和对象的定义
> 类是抽象的，不占用内存，而对象是具体的，占用存储空间
> - 类声明的一般形式：
> ```cpp
> class 类名
> {
>   private:
>       私有的数据和成员函数;
>   public:
>       公用的数据和成员函数;
> };
> ```
>   - 其中private和public事成员访问限定符(member access specifier)，用它们来声明各成员的访问属性。被声明为私有的成员，只能被在本类中的成员函数引用，类外不能调用(**友元类**例外)，被声明为公用的成员，既可以被本类中的成员函数所引用，也可以被类的作用域内的其他函数引用。
>   - 除了private和public之外，还有一种成员访问限定符protected(受保护的)，用protected声明的成员称为受保护的成员，它不能被类外访问，但可以被**派生类的成员函数**访问
>   - 在声明类类型时，声明为private的成员和声明为public的成员的次序任意，既可以先出现private部分，也可以先出现public部分。在一个类体中不一定都包含private和public部分。如果不写则默认为private。一个类体中，关键字private和public可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时(最后一个右花括号)为止。但是为了使程序清晰，应该尽量使每一种成员访问限定符在类体中只出现一次。先写public再写private可以使用户注意力集中在能被外界调用的成员上，使阅读者的思路更清晰。
> - 定义对象的方法：
>   - 先声明类类型，然后再定义对象  1) class 类名 对象名  2) 类名 对象名
>   - 在声明类类型的同时定义对象
>   - 不出现类名，直接定义对象
> - 类和结构体类型的异同
>   - 在C++中，结构体的功能被继承的同时也有扩充，比如在结构体中也可以定义成员函数
>   - 用struct声明的类，其成员默认为为公用的，如果要分别指定其私有成员和公有成员，则应用private和public作显式声明
>   - 如果希望成员是公用的，使用struct比较方便。如果希望部分成员是私有的，宜用class。尽量使用class来建立类

#### 类的成员函数
> 并非要求所有的成员函数都指定位public。有的函数并不是准备为外界调用的，而是为本类中的成员函数所调用的，就应该将它们指定为private。这种支持其他函数的操作的函数叫**工具函数(utility function)**。
> - 在类外定义成员函数
>   - 必须在函数名前加上类名，予以限定(qualifed)，“::”是作用域限定符(field qualifier)，用它声明函数是属于哪个类的。``Student::display()``
>   - 类函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前，否则编译时会出错。
> - inline成员函数
>   - 在类体中定义的成员函数的规模一般都很小，而系统调用的过程所花费的时间开销相对是比较大的。调用一个函数的时间开销远远大于小规模函数体中全部语句的执行时间。为了减少时间开销，如果在类体中定义的成员函数中**不包括循环等控制结构**，C++系统会自动将它们作为**内置(inline)函数**来处理
>   - 如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline)函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。
>   - 值得注意的是，如果在类体外定义inline函数，则必须将类定义和成员函数定义都放在同一个头文件中(或同一源文件中),否则编译时无法进行置换。但是这样做，不利于类的接口与类的实现分离，不利于信息隐蔽。虽然效率提高了，但从软件工程质量的角度来看，这样做并不是好的办法。只要在类外定义的成员函数规模很小而调用频率较高时，才将此成员函数指定为内置函数。
> - 成员函数的存储方式：一个对象所占空间大小只取决于该对象中数据成员所占的空间，而与成员函数无关。函数代码是存储在对象空间之外的。需要注意的是：虽然调用不同对象的成员函数时都是执行同一段函数代码，但是执行结果一般是不相同的。为了区别不同对象中的数据，C++为此专门设立了一个this指针，用来指向不同的对象。
>   - 不论成员函数在类内定义还是在类外定义，成员函数的代码都用同一种方式存储，即**都不占用对象的存储空间**。
>   - 不要将成员函数的这种存储方式和inline函数的概念。不论是否用inline声明，成员函数的代码段都不占用对象的存储空间。
>   - 常常说“某某对象的成员函数”，是从逻辑的角度而言的，而成员函数的存储方式(不存储在对象空间内)，是从物理的角度而言的，是由计算机根据优化的原则实现的。

#### 对象成员的引用
> - 通过对象名和成员运算符访问对象中的成员：对象名.成员名
> - 通过指向对象的指针访问对象中的成员
> ```cpp
> class Time
> {
> public;
>    int hour;
>    int minute;
> };
> Time t, *p;       //定义对象t和指针变量p
> p = &t; 
> cout<<p->hour<<(*p).hour<<t.hour;  //可以看到，这三者等价
> ```
> - 通过对象的引用变量来访问对象中的成员
> ```cpp
> Time t1;    //定义对象t1
> Time &t2 = t1;     //定义Time类引用变量t2，并使之初始化为t1
> ```

#### 类的封装性和信息隐蔽
> - 公用接口与私有实现的分离的优点
>   - 如果想修改或扩充类的功能，只需修改本类中有关的数据成员和与它有关的成员函数，程序中类外的部分可以不用修改
>   - 若在编译时发现类中的数据读写有错，不必检查整个程序，只需检查本类中访问这些数据的少数成员函数
> - 类声明和成员函数定义的分离
>   - 在面向对象的程序设计中，一般将类的声明(包含成员函数的声明)放在指定的头文件中，如果用户想用该类，直接包含头文件即可。把成员函数的实现不放在头文件中
>   - 在实际工作中，并不是将一个类的声明做成一个头文件，而是将若干个常用的功能相近的类声明集中在一起，形成类库。类库包括两个组成部分：1)类声明头文件; 2)已经过编译的成员函数的定义，它是目标文件。一般只需要把类库装到C++编译系统所在的子目录下，并在程序中用#include命令行将有关的类声明的头文件包含到程序中，就可以使用这些类和其中的成员函数。注意：类声明和类实现一般是放在两个文本中的。
> - 几个名词：**方法(method)**：指对数据的操作。一个方法对应一种操作。显然，只有被声明为公用的方法(成员函数)才能被对象外界所激活。外界是通过发送“**消息**”(即一个调用命令)来激活有关方法的。

#### 例子
```cpp
//找出一个整型数组中的元素的最大值
#include <iostream>
using namespace std;
class ArrayMax
{
public:
    void SetValue();
    void MaxValue();
    void ShowValue();
private:
    int array[10];
    int max;
};

void ArrayMax::SetValue()
{
    int i;
    for (i = 0; i < 10; i++)
        cin>>array[i];
}

void ArrayMax::MaxValue()
{
    int i;
    max = array[0];
    for (i = 1; i < 10; i++)
        if (array[i] > max) max = array[i];
}

void ArrayMax::ShowValue()
{
    cout << "max = " << max << endl;
}

int main()
{
    ArrayMax arrmax;
    arrmax.SetValue();
    arrmax.MaxValue();
    arrmax.ShowValue();
    return 0;
}
```
