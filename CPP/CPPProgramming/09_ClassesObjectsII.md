#### 构造函数
> - 对象的初始化：如果一个数据成员未被赋值，则它的值是不可预知的，因为在系统为它分配内存时，保留了这些存储单元的原状，这就成了这些数据成员的初始值。而对象是一个实体，它反映了客观事物的属性，是应该有确定的值的。应当注意：类的数据成员是不能在声明类时初始化的，因为类并不是一个实体，而是一种抽象类型，并不占存储空间
>   - C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。
>   - 不管类是否为空类，均可被实例化，每个被实例化的类都有一个独一无二的地址
>   - 类的大小：
>       - 为类的非静态成员数据的类型大小之和． 
>       - 由编译器额外加入的成员变量的大小，用来支持语言的某些特性（如：指向虚函数的指针）． 
>       - 为了优化存取效率，进行的边缘调整（字节对齐）
>       - 与类中的构造函数，析构函数以及其他的成员函数无关。
> - 关于构造函数的使用：
>   - 在类对象进入其作用域时调用构造函数
>   - 构造函数没有返回值，因此也不需要在定义构造函数时声明类型。构造函数的作用只是对对象进行初始化
>   - 构造函数不需要用户调用，也不能被用于调用。构造函数是在定义对象时由系统自动执行的，而且只执行一次。一般声明为public
>   - 在构造函数的函数体中不仅可以对数据成员赋初值，而且可以包含其他语句，如cout语句。但一般不许加入与初始化无关的内容，以保持程序清晰
>   - 如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，只是这个构造函数的函数体是空的，也没有参数，不执行初始化操作(所以值为随机值)
> - 带参数的构造函数
>   ```cpp
>   class Box
>   {
>   public:
>       Box(int, int, int);     //声明带参数的构造函数
>       int volume();           //声明计算体积的函数
>   private:
>       int height;
>       int width;
>       int length;
>   };
>   Box::Box(int h, int w, int l)    //在类外定义带参数的构造函数
>   {
>       height = h;
>       width = w;
>       length = l;
>   }
>   int Box::volume()       //定义计算体积的函数
>   {
>       return (height * width * length);
>   }
>
>   int main()
>   {
>       Box box1(12, 23, 34);     //建立对象，并指定长宽高。带参数的构造函数中的形参，其对应的实参在定义对象时给定
>       cout<<"the volume is:"<<box1.volume()<<endl;
>       return 0;
>   }
>   ```
> - 用**参数初始化表**对数据成员初始化：``Box::Box(int h, int w, int l):height(h), width(w), length(l){}`` 左侧的初始化表表示：用形参h的值初始化数据成员height等等。这种写法**方便、简洁**。甚至可以直接在类体中(而不是在类外)定义构造函数。
> - 构造函数的重载：在一个类中可以定义多个构造函数，以便对类对象提供不同的初始化的方法，供用户选用。这些构造函数具有相同的名字，而参数的个数或参数的类型不同。这被称为构造函数的重载。
>   - 调用构造函数时不必给出实参的构造函数，称为默认构造函数(default constructor)，也叫做缺省构造函数。显然无参的构造函数属于默认构造函数，**一个类只能有一个默认构造函数**。**如果用户希望在创建对象时就能使数据成员有初值，就必须自己定义构造函数**
>   - 建立对象时选用无参构造函数，则定义对象：``Box box1;``而不是``Box box1();``左边的语句并不是定义Box类的对象box1，而是声明一个普通函数box1，此函数的返回值为Box类型。在程序中不应该出现调用无参构造函数(如Box())。即：**构造函数是不能被用户显式调用的**
>   - 尽管在一个类中可以包含多个构造函数，单数对于每一个对象来说，建立对象时只执行其中一个构造函数。
> - 使用默认参数的构造函数
> ```cpp
> class Box 
> {
> public:
>   Box(int h = 10, int w = 10, int l = 10); //在声明构造函数时指定默认参数
>   ...
> }
> ```
>   - 可以看到：在构造函数中使用默认参数是方便而有效的，它提供了建立对象时的多种选择，其作用相当于好几个重载的构造函数。
>   - 应该在声明构造函数时指定默认值，而不能只在定义构造函数时指定默认值。因为类定义是放在头文件中的，它是类的对外接口，用户是可以看到的。在声明构造函数时指定默认参数值，使用户知道在建立对象时怎样使用默认参数
>   - 形参名可以省略，``Box(int = 10, int = 10, int = 10);``
>   - 如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给实参。以下这种写法是错误的：
>   ```cpp
>   Box();         //声明一个无参的构造函数
>   Box(int = 10, int = 10, int = 10);    //声明一个全部参数都指定了默认值的构造函数
>
>   Box box1;         //编译系统无法识别应该调用哪个构造函数，出现歧义
>   ```
>   - 在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。

#### 析构函数(destructor)
> 当对象的生命周期结束时，会自动执行析构函数：1)如果在一个函数中定义了一个对象(它是自动局部对象)，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数；2)static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只有在main函数结束或调用exit函数结束程序时，才调用static局部对象的析构函数；3)如果定义了一个全局对象，则在程序的流程离开其作用域时，调用该全局对象的析构函数；4)如果用new运算符动态地创建了一个对象，当用delete运算符释放时，先调用该对象的析构函数
>> 析构函数的作用并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。
>
>> 析构函数不返回任何值，没有函数类型，也没有函数参数。由于没有参数，因此它不能被重载。一个类可以有多个构造函数，但只能有一个析构函数。
